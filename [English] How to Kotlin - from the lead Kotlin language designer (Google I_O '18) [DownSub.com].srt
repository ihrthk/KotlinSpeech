1
00:00:00,000 --> 00:00:01,952
[MUSIC PLAYING]

2
00:00:08,310 --> 00:00:10,110
JAMES LAU: Thank you.

3
00:00:10,110 --> 00:00:12,310
Thanks for being
here this morning.

4
00:00:12,310 --> 00:00:16,190
My name is James, and I'm part
of the Kotlin team at Google.

5
00:00:16,190 --> 00:00:20,160
Today, I have the pleasure
of introducing a very

6
00:00:20,160 --> 00:00:23,580
special guest from
JetBrains, who really

7
00:00:23,580 --> 00:00:26,078
requires no introduction.

8
00:00:28,950 --> 00:00:34,410
Now, all of you know
that Kotlin is now

9
00:00:34,410 --> 00:00:37,260
one of the most
loved programming

10
00:00:37,260 --> 00:00:38,710
languages in the world.

11
00:00:44,870 --> 00:00:47,510
And at Google I/O,
it's very rare for us

12
00:00:47,510 --> 00:00:49,580
to have external speakers.

13
00:00:49,580 --> 00:00:52,580
But this person
was here last year,

14
00:00:52,580 --> 00:00:56,630
and we invited him back because
we couldn't think of anybody

15
00:00:56,630 --> 00:00:59,990
else better to teach
Kotlin, other than one

16
00:00:59,990 --> 00:01:02,210
of the people who invented it.

17
00:01:02,210 --> 00:01:05,420
So please help me welcome
the lead language designer

18
00:01:05,420 --> 00:01:08,015
for Kotlin, Andrey Breslav.

19
00:01:08,015 --> 00:01:09,995
[APPLAUSE]

20
00:01:12,965 --> 00:01:14,450
ANDREY BRESLAV:
Thank you, James.

21
00:01:14,450 --> 00:01:16,070
Thanks for a great introduction.

22
00:01:16,070 --> 00:01:16,790
Hello, everybody.

23
00:01:16,790 --> 00:01:19,150
I'm very glad to see you here.

24
00:01:19,150 --> 00:01:22,670
Today, I'm going to talk
about what can it be--

25
00:01:22,670 --> 00:01:24,290
Kotlin-- I guess.

26
00:01:24,290 --> 00:01:28,650
And I really am going
to do a live demo,

27
00:01:28,650 --> 00:01:32,030
so please bring my demo on.

28
00:01:32,030 --> 00:01:36,770
So the reason why I have this
horrible code in the slides

29
00:01:36,770 --> 00:01:40,910
is that we are all learning,
and our old habits sometimes

30
00:01:40,910 --> 00:01:42,260
get in the way.

31
00:01:42,260 --> 00:01:47,180
So I'll be presenting today on
the topic of how you get out

32
00:01:47,180 --> 00:01:50,810
of your Java habits and
get to your Kotlin habits.

33
00:01:50,810 --> 00:01:53,330
So we all come from different
backgrounds, of course.

34
00:01:53,330 --> 00:01:56,480
And many of us started with
the Java programming language

35
00:01:56,480 --> 00:01:59,720
and built up our knowledge
of programming through this.

36
00:01:59,720 --> 00:02:01,460
So we remember many things.

37
00:02:01,460 --> 00:02:05,340
And the thing is Kotlin has
been inspired by many languages,

38
00:02:05,340 --> 00:02:07,230
including the Java
programming language.

39
00:02:07,230 --> 00:02:11,660
So you can reproduce many of
the Java constructs in Kotlin.

40
00:02:11,660 --> 00:02:12,890
And it will work.

41
00:02:12,890 --> 00:02:15,630
You can get your
job done this way,

42
00:02:15,630 --> 00:02:19,120
but it can be, in many
cases, improved dramatically.

43
00:02:19,120 --> 00:02:23,420
So this particular example
is about declaring classes.

44
00:02:23,420 --> 00:02:26,240
And you can see here that I
have a Kotlin class on the left

45
00:02:26,240 --> 00:02:28,010
and the Java class on the right.

46
00:02:28,010 --> 00:02:29,700
And they look very similar.

47
00:02:29,700 --> 00:02:32,910
But this is definitely not
how we write Kotlin code.

48
00:02:32,910 --> 00:02:34,660
So what do you are
actually supposed to do

49
00:02:34,660 --> 00:02:37,790
is remove all the
unnecessary stuff.

50
00:02:37,790 --> 00:02:40,700
What I have to say here is
two properties, one class.

51
00:02:40,700 --> 00:02:41,810
That's it, right?

52
00:02:41,810 --> 00:02:44,210
So I can try to
transform it by hand,

53
00:02:44,210 --> 00:02:46,790
but I actually want to
show off a nice tool.

54
00:02:46,790 --> 00:02:49,600
And simply copy and paste
the code from the Java side

55
00:02:49,600 --> 00:02:53,000
to the Kotlin side, so it
will use the Java to Kotlin

56
00:02:53,000 --> 00:02:57,280
converter built into the
IDE, and do it for me.

57
00:02:57,280 --> 00:02:59,900
So boom, there it is.

58
00:02:59,900 --> 00:03:02,450
A single line that's
actually all you

59
00:03:02,450 --> 00:03:08,150
needed to declare one
class, two properties.

60
00:03:08,150 --> 00:03:08,900
That's it.

61
00:03:08,900 --> 00:03:11,385
All I have here is a class
with a primary constructor.

62
00:03:11,385 --> 00:03:13,760
So it has two parameters and
both of them are properties.

63
00:03:13,760 --> 00:03:15,950
And that's all
you wanted to say.

64
00:03:15,950 --> 00:03:19,520
So this is one of
the things that

65
00:03:19,520 --> 00:03:23,960
demonstrates how cheap
declaring classes is in Kotlin.

66
00:03:23,960 --> 00:03:26,390
And there's a
consequence to this.

67
00:03:26,390 --> 00:03:28,560
So look at this code.

68
00:03:28,560 --> 00:03:31,940
Here, it's obviously not how
you're supposed to write code

69
00:03:31,940 --> 00:03:33,410
in any language, actually.

70
00:03:33,410 --> 00:03:35,930
I wanted to parse a full
name into a first name

71
00:03:35,930 --> 00:03:37,350
and a last name.

72
00:03:37,350 --> 00:03:39,530
And so that's what
I'm doing here.

73
00:03:39,530 --> 00:03:43,100
But how do I pack the result
to put it out of the function?

74
00:03:43,100 --> 00:03:46,110
I don't have a way of returning
two things from a function.

75
00:03:46,110 --> 00:03:47,360
I have to put into one object.

76
00:03:47,360 --> 00:03:52,670
And I'm abusing a list here,
then awkwardly taking out one

77
00:03:52,670 --> 00:03:55,940
and the other to make a
first name and a last name.

78
00:03:55,940 --> 00:03:57,790
Don't do this in any language.

79
00:03:57,790 --> 00:04:00,700
But there is kind of
a psychological reason

80
00:04:00,700 --> 00:04:03,440
to doing this, at least
in our old habits,

81
00:04:03,440 --> 00:04:05,810
because declaring classes
is expensive, right?

82
00:04:05,810 --> 00:04:09,530
You have to create a new
file, put a lot of code in it.

83
00:04:09,530 --> 00:04:10,610
It's kind of awkward.

84
00:04:10,610 --> 00:04:12,320
But in Kotlin, you
don't have to do this.

85
00:04:12,320 --> 00:04:15,380
All you need to say,
my class, full name,

86
00:04:15,380 --> 00:04:21,050
with first and last
names as properties.

87
00:04:21,050 --> 00:04:26,630
And then, all I need to do
here is just return that.

88
00:04:26,630 --> 00:04:29,780
So my full name.

89
00:04:29,780 --> 00:04:30,620
Here it goes.

90
00:04:30,620 --> 00:04:35,510
And now instead of indices, I
can say first and last right

91
00:04:35,510 --> 00:04:36,450
here.

92
00:04:36,450 --> 00:04:38,936
So that's the idea.

93
00:04:38,936 --> 00:04:40,310
Classes being
cheap is not always

94
00:04:40,310 --> 00:04:42,310
saving you time at
the declaration site,

95
00:04:42,310 --> 00:04:43,880
it's saving you mental effort.

96
00:04:43,880 --> 00:04:47,780
You can represent your
multiple return as a class

97
00:04:47,780 --> 00:04:49,210
and it doesn't
cost you anything.

98
00:04:49,210 --> 00:04:52,430
So if I run this, you'll
see that my equals

99
00:04:52,430 --> 00:04:56,360
doesn't work, obviously, because
that's a single-line class.

100
00:04:56,360 --> 00:05:01,120
And so now I'll go to
declare equals there,

101
00:05:01,120 --> 00:05:03,360
and then a hash code there,
and so on and so forth.

102
00:05:03,360 --> 00:05:04,310
It's so verbose.

103
00:05:04,310 --> 00:05:06,770
But I really don't need
to do this in Kotlin,

104
00:05:06,770 --> 00:05:08,720
because you probably
know that there is

105
00:05:08,720 --> 00:05:10,730
something called data classes.

106
00:05:10,730 --> 00:05:12,950
Who knows data classes?

107
00:05:12,950 --> 00:05:14,510
Many people, good.

108
00:05:14,510 --> 00:05:17,000
So you know that I simply
put this single keyword there

109
00:05:17,000 --> 00:05:19,590
and the compiler generates many
things for me-- it's equal,

110
00:05:19,590 --> 00:05:21,170
it's hash code,
it's to a string,

111
00:05:21,170 --> 00:05:22,670
and many other
convenient methods.

112
00:05:22,670 --> 00:05:24,980
So that's it.

113
00:05:24,980 --> 00:05:28,760
Change your mind about
how expensive a class is.

114
00:05:28,760 --> 00:05:33,890
You can use it easily in
all your abstractions.

115
00:05:33,890 --> 00:05:38,550
So more or less done
with the warm up.

116
00:05:38,550 --> 00:05:40,970
Let's look at something else--

117
00:05:40,970 --> 00:05:42,300
properties.

118
00:05:42,300 --> 00:05:43,770
So we talked about classes.

119
00:05:43,770 --> 00:05:46,950
We'll go through properties,
and then go over to functions.

120
00:05:46,950 --> 00:05:49,880
So here is a property done
the way you shouldn't do it

121
00:05:49,880 --> 00:05:51,570
in Kotlin, again.

122
00:05:51,570 --> 00:05:54,050
So the problems that
I showed you before

123
00:05:54,050 --> 00:05:57,040
were kind of one-liners where
both the getter and setter is

124
00:05:57,040 --> 00:05:57,890
trivial.

125
00:05:57,890 --> 00:05:59,870
If you want a custom
setter, you definitely

126
00:05:59,870 --> 00:06:01,820
don't define functions for that.

127
00:06:01,820 --> 00:06:05,644
You have your custom setter
syntax, as you probably know.

128
00:06:05,644 --> 00:06:07,310
If you know data
classes, you know that.

129
00:06:07,310 --> 00:06:10,950
So inside a custom setter,
you have field to--

130
00:06:10,950 --> 00:06:13,810
not filed, but field--

131
00:06:13,810 --> 00:06:16,270
to write to your backend
storage, but that's it.

132
00:06:16,270 --> 00:06:20,270
You don't need to introduce
extra names in anything else.

133
00:06:20,270 --> 00:06:21,910
So that's
straightforward, right?

134
00:06:21,910 --> 00:06:24,880
But then look at this code.

135
00:06:24,880 --> 00:06:28,330
So here is already
some sensible logic.

136
00:06:28,330 --> 00:06:33,280
I have two properties, one
of them private and nullable

137
00:06:33,280 --> 00:06:34,900
and mutable.

138
00:06:34,900 --> 00:06:37,930
And on my first access, I'm
checking if that's null,

139
00:06:37,930 --> 00:06:40,330
and then I compute a
value and write into it.

140
00:06:40,330 --> 00:06:44,530
And then I output,
return it from my getter.

141
00:06:44,530 --> 00:06:45,250
So what is it?

142
00:06:45,250 --> 00:06:47,020
It's a lazy property, right?

143
00:06:47,020 --> 00:06:49,220
I personally wrote
dozens and thousands

144
00:06:49,220 --> 00:06:52,250
of those in Java and
many other languages,

145
00:06:52,250 --> 00:06:54,460
so I got kind of bored by that.

146
00:06:54,460 --> 00:06:57,100
And that's why Kotlin has an
abstraction mechanism called

147
00:06:57,100 --> 00:06:58,930
delegation for properties.

148
00:06:58,930 --> 00:07:02,850
So delegated properties
let you get rid

149
00:07:02,850 --> 00:07:05,680
of all the repetition
of this lazy logic.

150
00:07:05,680 --> 00:07:07,880
All we care about is
this expression here.

151
00:07:07,880 --> 00:07:10,590
So let's just do it.

152
00:07:10,590 --> 00:07:16,680
Implement my property by
just lazy of all this.

153
00:07:21,180 --> 00:07:22,610
This is it.

154
00:07:22,610 --> 00:07:25,010
So what I'm having
now, I'm saying

155
00:07:25,010 --> 00:07:29,120
my property is not simply
initialized by something.

156
00:07:29,120 --> 00:07:32,450
It's delegated to
this lazy thing here.

157
00:07:32,450 --> 00:07:35,400
And upon first access, this
lambda will be executed.

158
00:07:35,400 --> 00:07:38,120
And then, the rest will
be stored by the library.

159
00:07:38,120 --> 00:07:39,860
So lazy is not a
language construct,

160
00:07:39,860 --> 00:07:42,020
it's just a library function.

161
00:07:42,020 --> 00:07:43,760
You can define your own.

162
00:07:43,760 --> 00:07:46,950
And the library provides
you with many other things.

163
00:07:46,950 --> 00:07:50,210
So the takeaway
here is that if you

164
00:07:50,210 --> 00:07:55,260
have a common kind of property,
like observable for example,

165
00:07:55,260 --> 00:07:58,860
when you need to be notified
that something was modified,

166
00:07:58,860 --> 00:08:00,900
use a library or write your own.

167
00:08:00,900 --> 00:08:04,850
So here, delegates.observable
does the job

168
00:08:04,850 --> 00:08:06,200
from the standard library.

169
00:08:06,200 --> 00:08:10,970
But if you like, you don't
have to write code like this.

170
00:08:10,970 --> 00:08:14,720
When you have one property,
and then the other property,

171
00:08:14,720 --> 00:08:17,870
and the other doing the same and
same thing over and over again,

172
00:08:17,870 --> 00:08:20,600
all you need to do
is this, actually.

173
00:08:20,600 --> 00:08:24,050
Declare a single class
that encapsulates

174
00:08:24,050 --> 00:08:27,350
the logic of your property,
like your generic getter

175
00:08:27,350 --> 00:08:28,837
and generic setter.

176
00:08:28,837 --> 00:08:29,420
And that's it.

177
00:08:29,420 --> 00:08:33,320
You can now simply refer to
this class in many properties

178
00:08:33,320 --> 00:08:37,159
and get your business
logic database access,

179
00:08:37,159 --> 00:08:38,630
all kinds of validation.

180
00:08:38,630 --> 00:08:42,500
Anything you like can be
abstracted as a library

181
00:08:42,500 --> 00:08:45,220
and then reused
across your project.

182
00:08:45,220 --> 00:08:47,830
Does it make sense?

183
00:08:47,830 --> 00:08:49,909
Who uses this already?

184
00:08:49,909 --> 00:08:50,450
I don't know.

185
00:08:50,450 --> 00:08:51,074
So many people.

186
00:08:51,074 --> 00:08:52,040
You actually should.

187
00:08:52,040 --> 00:08:55,290
I'm sure you can
benefit from this.

188
00:08:55,290 --> 00:08:58,360
So this is more or less
it about properties.

189
00:08:58,360 --> 00:08:59,910
And now, let's get to functions.

190
00:08:59,910 --> 00:09:01,920
Functions are very
important, right?

191
00:09:01,920 --> 00:09:05,330
So again, this is
very horrible code.

192
00:09:05,330 --> 00:09:07,910
Don't write code like
this in Kotlin, please.

193
00:09:07,910 --> 00:09:10,130
This is very much
inspired by our habits

194
00:09:10,130 --> 00:09:12,200
in the Java programming
language, when I have

195
00:09:12,200 --> 00:09:14,570
to put everything into a class.

196
00:09:14,570 --> 00:09:18,470
So StringUtil-- does your
project has its own StringUtil

197
00:09:18,470 --> 00:09:20,375
class?

198
00:09:20,375 --> 00:09:25,480
Oh, if it doesn't, it's just
a very new project, right?

199
00:09:25,480 --> 00:09:28,692
So any of my projects have them.

200
00:09:28,692 --> 00:09:30,900
But the thing is, in Kotlin,
it's a little different.

201
00:09:30,900 --> 00:09:32,420
You don't have to use a class.

202
00:09:32,420 --> 00:09:35,750
Well, first of all, Kotlin
classes don't have statics.

203
00:09:35,750 --> 00:09:38,060
So to use these functions
from this class,

204
00:09:38,060 --> 00:09:40,890
you have to say a
StringUtil, parentheses,

205
00:09:40,890 --> 00:09:42,789
which makes a new object.

206
00:09:42,789 --> 00:09:44,330
I don't want a new
object every time.

207
00:09:44,330 --> 00:09:48,450
I want it like this, so I turn
this class into an object.

208
00:09:48,450 --> 00:09:50,610
It's a little bit of an
improvement in my insanity,

209
00:09:50,610 --> 00:09:51,110
right?

210
00:09:51,110 --> 00:09:52,730
So I was creating
an object every time

211
00:09:52,730 --> 00:09:53,896
I wanted to call a function.

212
00:09:53,896 --> 00:09:55,410
That's crazy.

213
00:09:55,410 --> 00:09:59,300
But really, in Kotlin, I don't
need any enclosing container

214
00:09:59,300 --> 00:10:02,920
at all because I have
top-level functions.

215
00:10:02,920 --> 00:10:06,050
So this may seem obvious like
functions, what are they?

216
00:10:06,050 --> 00:10:07,630
They're just
declarations, right?

217
00:10:07,630 --> 00:10:10,760
But some languages have them
only in classes and many people

218
00:10:10,760 --> 00:10:13,940
learn this and rely on this.

219
00:10:13,940 --> 00:10:15,800
So this is a lot
more of a Kotlin way,

220
00:10:15,800 --> 00:10:18,320
but it's still
not great in terms

221
00:10:18,320 --> 00:10:21,710
of what you can achieve with
Kotlin, because here, you

222
00:10:21,710 --> 00:10:23,830
have two overloads.

223
00:10:23,830 --> 00:10:27,610
So getFirstWord is
supposed to parse a string,

224
00:10:27,610 --> 00:10:32,010
find a first space, and take
the first word, and return it.

225
00:10:32,010 --> 00:10:35,240
But what if the separator
is not a space, but a comma

226
00:10:35,240 --> 00:10:36,840
or something?

227
00:10:36,840 --> 00:10:39,170
So here is a more
full-featured version.

228
00:10:39,170 --> 00:10:41,270
And then, this is how
you'll call it actually

229
00:10:41,270 --> 00:10:43,460
in most contexts.

230
00:10:43,460 --> 00:10:47,380
So what I wanted to express
here is just a default value.

231
00:10:47,380 --> 00:10:50,510
In Java, we are used to
using overloads for this,

232
00:10:50,510 --> 00:10:53,240
and also some people
use nullable parameters

233
00:10:53,240 --> 00:10:56,870
like pass and null here, and
I'll give you a default value.

234
00:10:56,870 --> 00:10:58,040
Don't do this in Kotlin.

235
00:10:58,040 --> 00:10:59,240
You don't need to.

236
00:10:59,240 --> 00:11:03,580
So all you need to do actually,
is simply specify your default.

237
00:11:03,580 --> 00:11:05,360
My default is space, here.

238
00:11:05,360 --> 00:11:07,210
That's it.

239
00:11:07,210 --> 00:11:10,090
So there was no need
to emulate defaults.

240
00:11:10,090 --> 00:11:11,660
They are both into the language.

241
00:11:11,660 --> 00:11:15,350
And same for when you
have many, many default

242
00:11:15,350 --> 00:11:17,150
parameters with
different values,

243
00:11:17,150 --> 00:11:19,340
like multiple Booleans,
so on, so forth.

244
00:11:19,340 --> 00:11:24,500
You can just use named parameter
syntax to express which of them

245
00:11:24,500 --> 00:11:25,250
you actually need.

246
00:11:25,250 --> 00:11:28,560
And all of the rest
will be used by default.

247
00:11:28,560 --> 00:11:31,520
So this makes functions
fewer in the first place,

248
00:11:31,520 --> 00:11:35,221
and then a lot more expressive.

249
00:11:35,221 --> 00:11:35,720
OK.

250
00:11:35,720 --> 00:11:37,535
Good with functions, right?

251
00:11:37,535 --> 00:11:41,360
Well, actually, this
function is kind of midway

252
00:11:41,360 --> 00:11:45,740
between the Kotlin
style and the Java style

253
00:11:45,740 --> 00:11:48,350
because it's actually
working on strings.

254
00:11:48,350 --> 00:11:52,000
Very much a good idea to put
this into a string class.

255
00:11:52,000 --> 00:11:53,690
Oh, wait, it's not.

256
00:11:53,690 --> 00:11:55,970
Because the string class
is not controlled by you,

257
00:11:55,970 --> 00:11:58,610
you can't put everything
into the string class.

258
00:11:58,610 --> 00:12:02,570
And you really want to keep
the string API minimal.

259
00:12:02,570 --> 00:12:04,540
So what I would
really like to do

260
00:12:04,540 --> 00:12:08,240
is something like this,
where I can say my string,

261
00:12:08,240 --> 00:12:11,270
getFirstWord, and that's it.

262
00:12:11,270 --> 00:12:13,830
So it looks like a method.

263
00:12:13,830 --> 00:12:16,142
It's called an extension
function, actually.

264
00:12:16,142 --> 00:12:17,600
It's not sitting
in a string class.

265
00:12:17,600 --> 00:12:22,061
I didn't go into the JDK and
alter the class I can control.

266
00:12:22,061 --> 00:12:23,310
But still, it works like this.

267
00:12:23,310 --> 00:12:27,610
So this is the
mechanism you can use.

268
00:12:27,610 --> 00:12:31,400
I'll do it manually to
illustrate how it works here.

269
00:12:31,400 --> 00:12:33,490
So I have a receiver
of type string.

270
00:12:33,490 --> 00:12:35,890
Now, I don't need this
parameter anymore.

271
00:12:35,890 --> 00:12:41,560
And I can say this dot
here, and use my this here

272
00:12:41,560 --> 00:12:45,710
or omit all of this
on the left-hand side.

273
00:12:45,710 --> 00:12:50,620
So now, I'll be able
to use it this way.

274
00:12:50,620 --> 00:12:52,150
Make sense?

275
00:12:52,150 --> 00:12:53,670
I can do the same
with a property.

276
00:12:53,670 --> 00:12:57,340
Actually, it would be very
nice to do it this way--

277
00:12:57,340 --> 00:13:00,850
just so I have first
word as a property name.

278
00:13:00,850 --> 00:13:03,972
And you can have an
extension property.

279
00:13:03,972 --> 00:13:05,680
Of course, there will
be no customization

280
00:13:05,680 --> 00:13:10,290
for the separator, but
otherwise you're good to go.

281
00:13:10,290 --> 00:13:13,030
Yep, I'll just need
to put a space here.

282
00:13:13,030 --> 00:13:13,840
And that's it.

283
00:13:13,840 --> 00:13:16,360
So extension functions,
extension properties--

284
00:13:16,360 --> 00:13:17,860
it's actually a
very important idea.

285
00:13:17,860 --> 00:13:19,720
It's not only just convenience.

286
00:13:19,720 --> 00:13:23,380
It allows you to keep your
classes really minimal.

287
00:13:23,380 --> 00:13:26,320
So look at the string
class in Kotlin.

288
00:13:26,320 --> 00:13:29,412
It's only five methods.

289
00:13:29,412 --> 00:13:31,870
If you compare that to Java,
it will be screens and screens

290
00:13:31,870 --> 00:13:34,070
of declarations.

291
00:13:34,070 --> 00:13:36,100
So you can keep
your API minimal.

292
00:13:36,100 --> 00:13:39,400
And all the utility
functions can be extensions,

293
00:13:39,400 --> 00:13:42,280
can sit in different libraries,
can be modularized like this.

294
00:13:42,280 --> 00:13:47,910
And that's a very important
tool for designing APIs.

295
00:13:47,910 --> 00:13:51,690
Do you have questions?

296
00:13:51,690 --> 00:13:52,534
OK.

297
00:13:52,534 --> 00:13:53,700
I couldn't take them anyway.

298
00:13:56,930 --> 00:13:59,630
OK, now, let's have
a look at this.

299
00:13:59,630 --> 00:14:02,060
Here, I'm doing
something very typical.

300
00:14:02,060 --> 00:14:03,360
I'm traversing a hierarchy.

301
00:14:03,360 --> 00:14:06,244
So I have containers
and leaf elements.

302
00:14:06,244 --> 00:14:07,910
Containers can be
nested in one another.

303
00:14:07,910 --> 00:14:09,150
Leaf elements sit there.

304
00:14:09,150 --> 00:14:10,670
All leaf elements
hold text and I

305
00:14:10,670 --> 00:14:13,280
want to extract all the
text from this hierarchy.

306
00:14:13,280 --> 00:14:14,600
Pretty straightforward.

307
00:14:14,600 --> 00:14:18,791
So my classes are
three lines of code--

308
00:14:18,791 --> 00:14:19,290
not much.

309
00:14:19,290 --> 00:14:20,081
There's an element.

310
00:14:20,081 --> 00:14:22,720
There's a container with
the list of children.

311
00:14:22,720 --> 00:14:24,440
There is text.

312
00:14:24,440 --> 00:14:26,450
Now, I'm traversing this.

313
00:14:26,450 --> 00:14:28,220
So I'm using
extension functions.

314
00:14:28,220 --> 00:14:31,430
I'm using top-level functions,
everything as I told you.

315
00:14:31,430 --> 00:14:34,610
So it's all right, but
I don't like this code.

316
00:14:34,610 --> 00:14:36,020
Why don't I like it?

317
00:14:36,020 --> 00:14:40,170
Here, to traverse a
hierarchy, I need recursion.

318
00:14:40,170 --> 00:14:43,430
So I need to pass the string
builder down the stack

319
00:14:43,430 --> 00:14:48,160
and add to it as I'm
going down the tree.

320
00:14:48,160 --> 00:14:51,500
But then, I end up with
top-level function that's

321
00:14:51,500 --> 00:14:53,900
only needed by this one here.

322
00:14:53,900 --> 00:14:56,900
So this one is not
really needed anywhere

323
00:14:56,900 --> 00:14:58,410
but inside this function.

324
00:14:58,410 --> 00:15:02,840
So what I'd really like to
do is just put it inside--

325
00:15:02,840 --> 00:15:07,700
just go here and make
it a local function.

326
00:15:07,700 --> 00:15:12,260
So again, it's just expressing
that nobody else needs this.

327
00:15:12,260 --> 00:15:13,990
You don't need private
helpers anymore--

328
00:15:13,990 --> 00:15:15,897
a look for local helpers.

329
00:15:15,897 --> 00:15:17,480
And this can be
improved a little bit.

330
00:15:17,480 --> 00:15:20,690
You can actually
make use of closure.

331
00:15:20,690 --> 00:15:25,610
So I can create my
string builder right here

332
00:15:25,610 --> 00:15:27,260
and get rid of all this.

333
00:15:27,260 --> 00:15:31,190
So I don't need to return
or take parameters here.

334
00:15:31,190 --> 00:15:36,560
All I need here is use
whatever is declared above.

335
00:15:36,560 --> 00:15:41,660
And then I just do
extractText of e right here

336
00:15:41,660 --> 00:15:46,080
and return string
builder toString.

337
00:15:46,080 --> 00:15:49,100
ExtractText-- oh, sorry-- it's
an extension function, right?

338
00:15:52,120 --> 00:15:54,310
No, sorry.

339
00:15:54,310 --> 00:15:58,680
Yeah, so here is how it goes.

340
00:15:58,680 --> 00:16:01,710
You can turn something into
a local function and leverage

341
00:16:01,710 --> 00:16:02,470
closure.

342
00:16:02,470 --> 00:16:05,110
So this variable is declared
outside my function.

343
00:16:05,110 --> 00:16:08,340
It's not accessible to
anyone outside the outer.

344
00:16:08,340 --> 00:16:11,310
And I'm using it
here and that's it.

345
00:16:11,310 --> 00:16:16,090
Now, local functions, extension
functions, top-level functions,

346
00:16:16,090 --> 00:16:17,580
default parameters-- use these.

347
00:16:17,580 --> 00:16:19,470
They will make your code nicer.

348
00:16:19,470 --> 00:16:23,480
Now, let's look at
what's still there.

349
00:16:23,480 --> 00:16:25,820
Do you see grey code?

350
00:16:25,820 --> 00:16:27,379
Grey code is useless.

351
00:16:27,379 --> 00:16:29,670
The IDE and the compiler show
you that something is not

352
00:16:29,670 --> 00:16:32,130
needed there, and
it actually isn't.

353
00:16:32,130 --> 00:16:36,210
This class is redundant because
we have this is check here.

354
00:16:36,210 --> 00:16:38,250
So you simply can remove this.

355
00:16:38,250 --> 00:16:39,640
And I don't know if you see--

356
00:16:39,640 --> 00:16:40,710
oh, yeah, you do--

357
00:16:40,710 --> 00:16:43,640
but the text variable
has gone green.

358
00:16:43,640 --> 00:16:44,310
Why is it green?

359
00:16:44,310 --> 00:16:47,310
It's because the compiler can
figure out the casts for you.

360
00:16:47,310 --> 00:16:48,570
It's actually much safer.

361
00:16:48,570 --> 00:16:49,660
It's not only convenient.

362
00:16:49,660 --> 00:16:53,140
I'm really annoyed at my
casts all over the place.

363
00:16:53,140 --> 00:16:56,220
So I know it's text.

364
00:16:56,220 --> 00:16:57,100
Why don't you know?

365
00:16:57,100 --> 00:16:59,010
Well, now it knows.

366
00:16:59,010 --> 00:17:01,740
And actually, you don't
need this variable either

367
00:17:01,740 --> 00:17:05,440
because it's the only usage.

368
00:17:05,440 --> 00:17:07,470
And it's same thing here.

369
00:17:07,470 --> 00:17:10,598
And then, my container
can be inline as well.

370
00:17:10,598 --> 00:17:12,209
So here it is.

371
00:17:12,210 --> 00:17:13,740
I can use smart casts.

372
00:17:13,740 --> 00:17:16,348
It makes your code
safer, more concise.

373
00:17:16,348 --> 00:17:18,929
And actually, it makes
all the casts that still

374
00:17:18,930 --> 00:17:20,310
are in your program meaningful.

375
00:17:20,310 --> 00:17:23,848
So when you see an as
operator in Kotlin now,

376
00:17:23,848 --> 00:17:25,209
you know it means something.

377
00:17:25,210 --> 00:17:28,260
It's not just a useless
compliment to the

378
00:17:28,260 --> 00:17:29,730
is check above.

379
00:17:29,730 --> 00:17:35,490
Also this thing here is kind of
stupid because what I'm doing,

380
00:17:35,490 --> 00:17:38,005
I'm just applying the same
function to everything.

381
00:17:38,005 --> 00:17:39,130
And it's a single function.

382
00:17:39,130 --> 00:17:43,500
So what I want to do
is something like this.

383
00:17:43,500 --> 00:17:47,580
That's a little
bit nicer looking.

384
00:17:47,580 --> 00:17:50,000
And then, let's look
at what we have.

385
00:17:50,000 --> 00:17:51,850
We are traversing a hierarchy.

386
00:17:51,850 --> 00:17:52,590
I have my leaves.

387
00:17:52,590 --> 00:17:54,150
I have my containers.

388
00:17:54,150 --> 00:17:56,230
And that's what I want
to express, right?

389
00:17:56,230 --> 00:17:58,420
I'm checking different cases.

390
00:17:58,420 --> 00:18:03,320
So to do that, it's a lot
nicer to use a when statement.

391
00:18:03,320 --> 00:18:07,330
When can switch in
types right here.

392
00:18:07,330 --> 00:18:09,750
But there is an
annoying thing about it.

393
00:18:09,750 --> 00:18:12,210
And it's again, coming
from my old habits.

394
00:18:12,210 --> 00:18:14,700
I'm declaring a close hierarchy.

395
00:18:14,700 --> 00:18:16,720
I have only containers
and text, right?

396
00:18:16,720 --> 00:18:19,460
I don't have anything else.

397
00:18:19,460 --> 00:18:23,111
But now, I have this pretty
annoying else case right here.

398
00:18:23,111 --> 00:18:23,610
Why?

399
00:18:23,610 --> 00:18:25,660
Because the compiler
has no idea.

400
00:18:25,660 --> 00:18:27,690
I don't have anything
but containers and text.

401
00:18:27,690 --> 00:18:31,690
It's just an abstract class
and I have some cases there.

402
00:18:31,690 --> 00:18:36,660
But you can actually express
this in Kotlin with sealed.

403
00:18:36,660 --> 00:18:38,520
I can have a sealed
class, which means

404
00:18:38,520 --> 00:18:39,960
all the subclasses are known.

405
00:18:39,960 --> 00:18:42,090
You can declare them
outside this file.

406
00:18:42,090 --> 00:18:43,920
And this way, the
IDE and the compiler

407
00:18:43,920 --> 00:18:46,210
know that this else is useless.

408
00:18:46,210 --> 00:18:49,740
So we went from almost
two screens of code

409
00:18:49,740 --> 00:18:53,700
to less than one, simply
applying the idioms of Kotlin

410
00:18:53,700 --> 00:18:54,900
to this code.

411
00:18:54,900 --> 00:18:56,951
Do you have questions?

412
00:18:56,951 --> 00:18:57,450
I'm sorry.

413
00:19:00,220 --> 00:19:00,720
All right.

414
00:19:03,550 --> 00:19:05,880
So now, let's just
continue with this exercise

415
00:19:05,880 --> 00:19:10,020
and look at some more examples
of expressions that are written

416
00:19:10,020 --> 00:19:12,020
like with old habits in mind.

417
00:19:12,020 --> 00:19:16,750
And we'll try to transform
them into something better.

418
00:19:16,750 --> 00:19:20,190
So the first thing that
really stands out here is var.

419
00:19:20,190 --> 00:19:22,350
I can't say never use var.

420
00:19:22,350 --> 00:19:24,030
Vars are useful.

421
00:19:24,030 --> 00:19:28,260
Mutable variables can be
used for many nice things.

422
00:19:28,260 --> 00:19:30,930
But it's kind of discouraged.

423
00:19:30,930 --> 00:19:32,990
If you need a var, you
need a very good reason.

424
00:19:32,990 --> 00:19:36,210
Here is not good reason
using a val, definitely.

425
00:19:36,210 --> 00:19:39,270
Then here, let's
look at these three.

426
00:19:39,270 --> 00:19:40,270
It's repetition.

427
00:19:40,270 --> 00:19:41,340
Repetition is ugly.

428
00:19:41,340 --> 00:19:43,350
Repetition is
error-prone, especially

429
00:19:43,350 --> 00:19:47,280
if this was not a single
name, but many things chained.

430
00:19:47,280 --> 00:19:49,440
So I would like to get
rid of this repetition.

431
00:19:49,440 --> 00:19:53,010
What I can do is say, with ex.

432
00:19:53,010 --> 00:19:56,040
Does anyone remember Pascal?

433
00:19:56,040 --> 00:19:57,245
Pascal, anyone?

434
00:19:57,245 --> 00:19:58,450
Oh, good.

435
00:19:58,450 --> 00:19:58,950
Good.

436
00:19:58,950 --> 00:20:01,200
I started in Pascal, almost.

437
00:20:01,200 --> 00:20:04,000
So it had this weird thing,
which was a building construct.

438
00:20:04,000 --> 00:20:06,257
In Kotlin, it's a function.

439
00:20:06,257 --> 00:20:06,840
We can use it.

440
00:20:06,840 --> 00:20:10,110
And here, we can get
rid of all the ex things

441
00:20:10,110 --> 00:20:12,970
here, just like this.

442
00:20:12,970 --> 00:20:14,790
And now it looks even
more stupid, right?

443
00:20:14,790 --> 00:20:16,230
I'm just assigning to
the same variables.

444
00:20:16,230 --> 00:20:16,813
Don't do that.

445
00:20:19,650 --> 00:20:23,400
OK, so now I have a print line
with string plus something,

446
00:20:23,400 --> 00:20:25,660
string plus something,
string plus something.

447
00:20:25,660 --> 00:20:26,460
It's awkward.

448
00:20:26,460 --> 00:20:28,780
Most languages now have
string interpolation.

449
00:20:28,780 --> 00:20:30,190
Kotlin has that as well.

450
00:20:30,190 --> 00:20:34,420
So what you actually
need here is this.

451
00:20:34,420 --> 00:20:37,860
OK, done with this one.

452
00:20:37,860 --> 00:20:40,270
Import things into
your scope with with.

453
00:20:40,270 --> 00:20:43,050
Use string
interpolation, it's nice.

454
00:20:43,050 --> 00:20:48,390
Now here, I'm creating
a map the old way.

455
00:20:48,390 --> 00:20:52,560
I can kind of make it a
little nicer like this

456
00:20:52,560 --> 00:20:55,710
by using my operators,
but it's really much nicer

457
00:20:55,710 --> 00:20:58,600
if I just use a
builder function.

458
00:20:58,600 --> 00:21:06,768
So what I can do here is replace
all my map things with pairs.

459
00:21:06,768 --> 00:21:13,560
Oh, not pairs, but pair, sorry.

460
00:21:13,560 --> 00:21:15,570
Typing when talking
is difficult.

461
00:21:15,570 --> 00:21:17,840
Yeah, so a map can be
constructed of pairs, right?

462
00:21:17,840 --> 00:21:21,500
And map was only a set of
pairs from key to value.

463
00:21:21,500 --> 00:21:25,030
But actually, pairs are
kind of redundant in this,

464
00:21:25,030 --> 00:21:29,652
so we're usually using
the to function here.

465
00:21:29,652 --> 00:21:31,860
It's not a built-in operator,
just a library function

466
00:21:31,860 --> 00:21:34,260
here, so this is how
you create a map.

467
00:21:34,260 --> 00:21:35,940
And when you want
to traverse the map,

468
00:21:35,940 --> 00:21:42,810
you can say here, key
and value, and just

469
00:21:42,810 --> 00:21:46,230
have your variables
like this, which makes

470
00:21:46,230 --> 00:21:49,470
for loops a lot more concise.

471
00:21:49,470 --> 00:21:53,010
This example of code,
with my if statement,

472
00:21:53,010 --> 00:21:57,060
is something I really hated
about my code in Java.

473
00:21:57,060 --> 00:22:03,490
Because these assignments here,
they all fall apart so easily,

474
00:22:03,490 --> 00:22:07,950
so I really like to do
things like this in Kotlin.

475
00:22:07,950 --> 00:22:11,860
So if, and many other things,
are actually expressions.

476
00:22:11,860 --> 00:22:13,590
This is something
pretty unfamiliar

477
00:22:13,590 --> 00:22:16,210
for the C language family.

478
00:22:16,210 --> 00:22:19,290
We are used to dividing
our code into statements

479
00:22:19,290 --> 00:22:20,370
and expressions, right?

480
00:22:20,370 --> 00:22:22,080
Statements are things
that have effects.

481
00:22:22,080 --> 00:22:24,210
Expressions are things
that have values.

482
00:22:24,210 --> 00:22:27,660
So you assign expressions to
variables and write statements

483
00:22:27,660 --> 00:22:29,790
to assign things to things.

484
00:22:29,790 --> 00:22:33,180
So Kotlin is halfway between
this procedural tradition

485
00:22:33,180 --> 00:22:34,560
and functional tradition.

486
00:22:34,560 --> 00:22:37,410
So we have a lot more
expressions than you're

487
00:22:37,410 --> 00:22:38,980
used to in other languages.

488
00:22:38,980 --> 00:22:40,080
So you can do this here.

489
00:22:40,080 --> 00:22:42,910
And of course, you
don't have to use a var.

490
00:22:42,910 --> 00:22:45,980
You don't have to
make a different line.

491
00:22:45,980 --> 00:22:47,710
And you can assign
it right away.

492
00:22:47,710 --> 00:22:50,474
So if expression, make it nicer.

493
00:22:50,474 --> 00:22:52,140
By the way, the result
of the expression

494
00:22:52,140 --> 00:22:55,380
is the last thing in the block.

495
00:22:55,380 --> 00:22:57,852
So the same for when.

496
00:22:57,852 --> 00:23:01,520
When is not simply
switch case on steroids,

497
00:23:01,520 --> 00:23:05,560
it's largely and
importantly, an expression.

498
00:23:05,560 --> 00:23:10,320
So you can also do
it like this, right?

499
00:23:10,320 --> 00:23:13,107
So not many returns
here, but one return here

500
00:23:13,107 --> 00:23:13,940
will be a lot nicer.

501
00:23:13,940 --> 00:23:17,520
Also you don't have to repeat
yourself, of course, this much.

502
00:23:17,520 --> 00:23:21,837
And you can say even this.

503
00:23:21,837 --> 00:23:24,420
By the way, if you want to check
if something is odd and even,

504
00:23:24,420 --> 00:23:25,770
don't do it like me.

505
00:23:25,770 --> 00:23:27,992
It's only for demo purposes.

506
00:23:27,992 --> 00:23:28,950
Don't try this at home.

507
00:23:28,950 --> 00:23:30,366
It will hurt.

508
00:23:33,200 --> 00:23:38,220
Yeah, so this one can be
further simplified like this.

509
00:23:38,220 --> 00:23:40,730
So again, you're trying
to remove the noise.

510
00:23:40,730 --> 00:23:42,320
When you see code
like this, just

511
00:23:42,320 --> 00:23:43,940
try to get rid of the noise.

512
00:23:43,940 --> 00:23:47,840
Noise is harmful for your brain.

513
00:23:47,840 --> 00:23:49,940
Last thing, just a
quick demo of what

514
00:23:49,940 --> 00:23:51,161
do you do with nullability.

515
00:23:51,161 --> 00:23:53,660
So these question marks-- who's
familiar with nullable types

516
00:23:53,660 --> 00:23:55,014
in Kotlin?

517
00:23:55,014 --> 00:23:55,680
How many people?

518
00:23:55,680 --> 00:23:57,750
I'll go really, really quick.

519
00:23:57,750 --> 00:23:59,720
So you can nullable types.

520
00:23:59,720 --> 00:24:02,310
And compiler makes you
do things like this.

521
00:24:02,310 --> 00:24:04,312
So it's in there now.

522
00:24:04,312 --> 00:24:05,270
The string is nullable.

523
00:24:05,270 --> 00:24:06,950
You can dereference it.

524
00:24:06,950 --> 00:24:10,330
You can either do this,
which says just safely

525
00:24:10,330 --> 00:24:11,336
dereference me--

526
00:24:11,336 --> 00:24:12,710
which by the way,
you can do here

527
00:24:12,710 --> 00:24:18,380
as well so you don't have
to write an if around it.

528
00:24:18,380 --> 00:24:21,770
And you can actually
simplify it like this.

529
00:24:21,770 --> 00:24:24,050
Another nice thing
is that you can

530
00:24:24,050 --> 00:24:32,870
use an elvis operator like
this, so to simplify your longer

531
00:24:32,870 --> 00:24:34,250
if statements into something.

532
00:24:34,250 --> 00:24:37,820
And this is kind of curious
because this is definitely

533
00:24:37,820 --> 00:24:39,380
in an expression
position, right?

534
00:24:39,380 --> 00:24:41,740
So how elvis works?

535
00:24:41,740 --> 00:24:44,660
Elvis takes an expression to
the left-hand side of a string,

536
00:24:44,660 --> 00:24:47,690
asks are you a
null really nicely.

537
00:24:47,690 --> 00:24:51,429
And then if it's a null, it
evaluates the right-hand side.

538
00:24:51,429 --> 00:24:53,720
But the right-hand side has
to be an expression, right?

539
00:24:53,720 --> 00:24:57,080
Basically, it's supposed
to be a default.

540
00:24:57,080 --> 00:24:59,500
So if you are now on
the left-hand side,

541
00:24:59,500 --> 00:25:01,400
use a default on
the right-hand side.

542
00:25:01,400 --> 00:25:04,550
But your default can
be just a return,

543
00:25:04,550 --> 00:25:07,430
which means that you don't
compute any value there.

544
00:25:07,430 --> 00:25:09,920
You just jump out
of the function.

545
00:25:09,920 --> 00:25:12,350
And that's a quite interesting
thing from the type system

546
00:25:12,350 --> 00:25:14,320
standpoint, but I'm not
giving a lecture here.

547
00:25:14,320 --> 00:25:17,630
I'm doing a demo.

548
00:25:17,630 --> 00:25:20,640
OK, we're good with expressions.

549
00:25:20,640 --> 00:25:22,690
Let's look at some
functional style.

550
00:25:22,690 --> 00:25:25,595
So people very often
refer to Kotlin

551
00:25:25,595 --> 00:25:28,280
as a functional language.

552
00:25:28,280 --> 00:25:30,160
I don't think it is, actually.

553
00:25:30,160 --> 00:25:32,420
I think Kotlin is a
multi-paradigm language that

554
00:25:32,420 --> 00:25:33,810
supports functional style.

555
00:25:33,810 --> 00:25:35,870
You don't have to write
functional in Kotlin,

556
00:25:35,870 --> 00:25:39,110
but it's oftentimes
very nice to do it.

557
00:25:39,110 --> 00:25:41,130
So let's have a look at this.

558
00:25:41,130 --> 00:25:44,210
So in my Java old
days in mind, I

559
00:25:44,210 --> 00:25:49,160
wrote this code, which just
goes over a list of numbers

560
00:25:49,160 --> 00:25:52,490
and picks those that
are divisible by 16,

561
00:25:52,490 --> 00:25:56,050
and then converts them to hex.

562
00:25:56,050 --> 00:26:00,750
So what it actually does
is filter map, right?

563
00:26:00,750 --> 00:26:05,220
Map is this one, and
filter is this one.

564
00:26:05,220 --> 00:26:10,610
So what I can do, even with the
help of my IDE, I can do this.

565
00:26:10,610 --> 00:26:14,330
So newer versions of all
programming languages

566
00:26:14,330 --> 00:26:15,820
have something like this.

567
00:26:15,820 --> 00:26:17,870
It can definitely leverage this.

568
00:26:17,870 --> 00:26:20,540
So this filter is a function.

569
00:26:20,540 --> 00:26:23,150
This lambda is a function value.

570
00:26:23,150 --> 00:26:26,300
You don't have, by the way,
to declare it as a variable.

571
00:26:26,300 --> 00:26:29,670
You can just get rid of it.

572
00:26:29,670 --> 00:26:31,880
So that's a lambda parameter.

573
00:26:31,880 --> 00:26:35,630
Kotlin has some nice
semi-functional things,

574
00:26:35,630 --> 00:26:39,320
like you can say anywhere in
your code, you can say also.

575
00:26:39,320 --> 00:26:44,850
You have this value, also do
this for me please-- like print

576
00:26:44,850 --> 00:26:46,930
this list for me.

577
00:26:46,930 --> 00:26:48,680
And then proceed with
what you were doing.

578
00:26:48,680 --> 00:26:51,620
Like never mind this, it's
just debug output or some side

579
00:26:51,620 --> 00:26:53,090
effect I want to insert here.

580
00:26:53,090 --> 00:26:55,370
Side effects are not very
functional, on the one hand.

581
00:26:55,370 --> 00:26:57,560
On the other hand, this is
very handy for debugging.

582
00:26:57,560 --> 00:26:59,140
You don't have to break
your chain apart, and so on,

583
00:26:59,140 --> 00:27:00,160
so forth.

584
00:27:00,160 --> 00:27:05,540
Use also, use let, use
run, and so on, so forth.

585
00:27:05,540 --> 00:27:09,230
There is one very deep thing
about functional abstractions

586
00:27:09,230 --> 00:27:11,457
in non-functional languages.

587
00:27:11,457 --> 00:27:13,790
When I do something like this,
I have my repeat function

588
00:27:13,790 --> 00:27:14,610
right here, right?

589
00:27:14,610 --> 00:27:17,000
So what it does,
it takes a number

590
00:27:17,000 --> 00:27:18,620
of times I want to
repeat something,

591
00:27:18,620 --> 00:27:20,640
and this something
is a function.

592
00:27:20,640 --> 00:27:22,940
By the way, you don't have
to invent your own function

593
00:27:22,940 --> 00:27:26,000
interface every time, just
use the function types here.

594
00:27:26,000 --> 00:27:28,330
It's a function that takes
an int or it takes a unit.

595
00:27:28,330 --> 00:27:31,000
Unit is something
you don't care about.

596
00:27:31,000 --> 00:27:33,290
Then, it simply
repeats it, right?

597
00:27:33,290 --> 00:27:40,070
So when I say repeat, I'm always
very much conscious about what

598
00:27:40,070 --> 00:27:42,950
it's going to cost me.

599
00:27:42,950 --> 00:27:44,790
So it's a function.

600
00:27:44,790 --> 00:27:47,040
It takes a lambda
as a parameter.

601
00:27:47,040 --> 00:27:49,857
So it's actually just
another parameter.

602
00:27:49,857 --> 00:27:52,190
The Kotlin custom is to write
it outside the parentheses

603
00:27:52,190 --> 00:27:55,880
because it looks more like a
language construct like this.

604
00:27:55,880 --> 00:27:59,600
But then, OK, I'm running this.

605
00:27:59,600 --> 00:28:02,300
I have to create a
lambda object, right?

606
00:28:02,300 --> 00:28:05,150
I have to create a lambda
object every time I

607
00:28:05,150 --> 00:28:06,430
do anything like this.

608
00:28:06,430 --> 00:28:08,140
So there is a cost
to this abstraction.

609
00:28:08,140 --> 00:28:08,960
It's nice code.

610
00:28:08,960 --> 00:28:10,250
I can reuse things.

611
00:28:10,250 --> 00:28:13,460
I can raise the level of
abstraction in my code.

612
00:28:13,460 --> 00:28:16,460
But there is a toll on that.

613
00:28:16,460 --> 00:28:19,880
Actually in Kotlin, you
can very often get rid

614
00:28:19,880 --> 00:28:22,280
of the toll of green lambdas--

615
00:28:22,280 --> 00:28:25,640
lambda objects-- for you, by
just using inline functions.

616
00:28:25,640 --> 00:28:28,400
When I say inline, my
code doesn't change.

617
00:28:28,400 --> 00:28:32,972
So here, nothing happened at
the call site that I can see.

618
00:28:32,972 --> 00:28:39,330
But if I say show
Kotlin bytecode,

619
00:28:39,330 --> 00:28:41,340
and just decompile
this into to Java--

620
00:28:41,340 --> 00:28:43,070
just to scare you a little bit.

621
00:28:43,070 --> 00:28:48,280
It was much of an
easy talk so far.

622
00:28:48,280 --> 00:28:50,310
So if I do this--

623
00:28:50,310 --> 00:28:52,110
here it goes-- it's
a simple for loop.

624
00:28:55,530 --> 00:28:57,810
Where did my lambda go?

625
00:28:57,810 --> 00:29:00,250
Well, the compiler
simply optimized it away.

626
00:29:00,250 --> 00:29:02,370
You don't need a lambda.

627
00:29:02,370 --> 00:29:06,420
So if you simply have your loop
here and you inline everything,

628
00:29:06,420 --> 00:29:07,560
you end up with a loop.

629
00:29:07,560 --> 00:29:08,460
That's it.

630
00:29:08,460 --> 00:29:13,300
So the big difference
in the mindset

631
00:29:13,300 --> 00:29:15,370
when you go from the
Java programming language

632
00:29:15,370 --> 00:29:16,840
to the Kotlin
programming language

633
00:29:16,840 --> 00:29:19,144
is that you still use lambdas,
but some of your lambdas

634
00:29:19,144 --> 00:29:19,810
are really free.

635
00:29:19,810 --> 00:29:22,030
And by the way, these
all are free too.

636
00:29:22,030 --> 00:29:24,610
So many, many lambdas
in the standard library

637
00:29:24,610 --> 00:29:25,990
are free abstractions.

638
00:29:25,990 --> 00:29:28,470
You don't have to
pay for calling them.

639
00:29:28,470 --> 00:29:31,970
It's just code
generated for you.

640
00:29:31,970 --> 00:29:36,340
So functional in Kotlin is not
only convenient, but also quite

641
00:29:36,340 --> 00:29:37,510
cheap.

642
00:29:37,510 --> 00:29:42,820
Speaking of cheap, by the way,
let's look at this example.

643
00:29:42,820 --> 00:29:45,980
So here, I'm trying to do
a parallel computation.

644
00:29:45,980 --> 00:29:47,880
Well, it's a stupid sample.

645
00:29:47,880 --> 00:29:50,000
Nobody does parallel
computation in bare threads,

646
00:29:50,000 --> 00:29:53,150
so on, so forth, but I
want to illustrate a point.

647
00:29:53,150 --> 00:29:54,790
So what I'm doing
here is, again,

648
00:29:54,790 --> 00:30:03,650
with my old habits in mind,
I'm creating 100,000 threads--

649
00:30:03,650 --> 00:30:06,840
100,000 threads, each of
which does some work--

650
00:30:06,840 --> 00:30:09,360
actually, sleeps for one second
and just prints a number.

651
00:30:09,360 --> 00:30:12,480
And then, I have to
join all these threads

652
00:30:12,480 --> 00:30:14,110
to my main thread.

653
00:30:14,110 --> 00:30:15,660
So if I run this--

654
00:30:15,660 --> 00:30:19,450
oh, oh, oh, that
was an exception.

655
00:30:19,450 --> 00:30:21,120
What was that?

656
00:30:21,120 --> 00:30:24,660
The Java lang out
of memory error.

657
00:30:24,660 --> 00:30:27,510
Basically, what it's
telling me, hey, you

658
00:30:27,510 --> 00:30:31,740
can not create 100,000 threads.

659
00:30:31,740 --> 00:30:33,600
Are you crazy there?

660
00:30:33,600 --> 00:30:35,900
It's 100,000 stacks.

661
00:30:35,900 --> 00:30:38,690
It doesn't fit into memory.

662
00:30:38,690 --> 00:30:42,000
Just get reasonable.

663
00:30:42,000 --> 00:30:43,350
And that's fair.

664
00:30:43,350 --> 00:30:45,670
OS threads are not cheap.

665
00:30:45,670 --> 00:30:47,650
You have to allocate
resources for threads.

666
00:30:47,650 --> 00:30:50,400
So you don't do such
silly things with threads,

667
00:30:50,400 --> 00:30:54,630
but I have this example
down through coroutines.

668
00:30:54,630 --> 00:30:57,564
Who knows about
coroutines in Kotlin?

669
00:30:57,564 --> 00:30:59,310
Oh, good.

670
00:30:59,310 --> 00:31:01,880
Who uses them in production?

671
00:31:01,880 --> 00:31:05,137
OK, soon enough you all will
be using them, I'm sure.

672
00:31:05,137 --> 00:31:05,970
So have a look here.

673
00:31:05,970 --> 00:31:07,720
It's very much the same code.

674
00:31:07,720 --> 00:31:11,250
So I'll just put it
side by side here.

675
00:31:11,250 --> 00:31:15,040
Very much the same code,
but instead of threads here,

676
00:31:15,040 --> 00:31:19,560
I'm creating async tasks
which are using coroutines

677
00:31:19,560 --> 00:31:20,580
underneath.

678
00:31:20,580 --> 00:31:23,310
So I'm still waiting for
one second and printing.

679
00:31:23,310 --> 00:31:27,540
And if I run this, there
is no out of memory.

680
00:31:27,540 --> 00:31:31,440
It's printing all the
numbers and I'm good.

681
00:31:31,440 --> 00:31:34,680
So again, Kotlin
introduced coroutines

682
00:31:34,680 --> 00:31:37,080
as a means of making
your asynchronous

683
00:31:37,080 --> 00:31:38,820
computations nicer.

684
00:31:38,820 --> 00:31:42,150
And that works, but
what's the cost of that?

685
00:31:42,150 --> 00:31:44,580
So the cost of that
is at least cheaper

686
00:31:44,580 --> 00:31:46,860
than having a thread
per each computation.

687
00:31:46,860 --> 00:31:48,480
Of course, nobody
does that exactly,

688
00:31:48,480 --> 00:31:50,710
but still coroutines
are very cheap.

689
00:31:50,710 --> 00:31:54,600
You can spin off like
100,000 coroutines, a million

690
00:31:54,600 --> 00:31:57,720
coroutines, and it doesn't
cost you nearly as much

691
00:31:57,720 --> 00:32:00,210
as anything like
that old threads.

692
00:32:00,210 --> 00:32:02,310
Let me illustrate something
coroutines are really

693
00:32:02,310 --> 00:32:05,770
good for right here.

694
00:32:05,770 --> 00:32:12,180
So here is a legacy
interface or--

695
00:32:12,180 --> 00:32:14,730
I don't know-- or a [INAUDIBLE]
interface-- whatever.

696
00:32:14,730 --> 00:32:19,200
So what we very often have to
do to make things asynchronous

697
00:32:19,200 --> 00:32:22,140
or make things like
reverse our dependencies,

698
00:32:22,140 --> 00:32:24,540
so on, so forth, is callbacks.

699
00:32:24,540 --> 00:32:27,709
So just ask me to do something.

700
00:32:27,709 --> 00:32:28,500
I'll do it for you.

701
00:32:28,500 --> 00:32:30,240
And I'll let you
know when I'm done.

702
00:32:30,240 --> 00:32:34,620
So here, I have my mock service,
a request, and a callback

703
00:32:34,620 --> 00:32:37,170
function that's passed to it.

704
00:32:37,170 --> 00:32:41,170
So when the work in
the comments are done,

705
00:32:41,170 --> 00:32:45,980
I'm calling the callback and
just passing my answer there.

706
00:32:45,980 --> 00:32:46,890
So that's all right.

707
00:32:46,890 --> 00:32:50,070
It's working for
everyone, right?

708
00:32:50,070 --> 00:32:51,990
But this is what the
code looks like when

709
00:32:51,990 --> 00:32:54,660
I want to exchange messages
between two services.

710
00:32:54,660 --> 00:32:59,430
So I just want to basically
send two messages in sequence.

711
00:32:59,430 --> 00:33:01,890
And here is what I have to do.

712
00:33:01,890 --> 00:33:03,590
First, request.

713
00:33:03,590 --> 00:33:04,350
Then a callback.

714
00:33:04,350 --> 00:33:05,880
This is the result
of the request.

715
00:33:05,880 --> 00:33:06,660
I print it.

716
00:33:06,660 --> 00:33:09,810
Then next request
inside that callback.

717
00:33:09,810 --> 00:33:10,950
And then print inside.

718
00:33:10,950 --> 00:33:13,860
So you see the staircase
right here, right?

719
00:33:13,860 --> 00:33:16,560
One step-- oh, sorry.

720
00:33:16,560 --> 00:33:18,780
One step, two
steps, three steps.

721
00:33:18,780 --> 00:33:20,820
And you can actually
get quite deep

722
00:33:20,820 --> 00:33:24,870
down this staircase,
which is not nice.

723
00:33:24,870 --> 00:33:26,820
So what I would
really love to do

724
00:33:26,820 --> 00:33:28,730
is something a little
more straightforward,

725
00:33:28,730 --> 00:33:30,910
but so this is
kind of tolerable.

726
00:33:30,910 --> 00:33:32,820
But what if-- just
imagine-- what if you

727
00:33:32,820 --> 00:33:35,940
needed to do like n calls?

728
00:33:35,940 --> 00:33:39,250
Just a number-- like
make a list of calls.

729
00:33:39,250 --> 00:33:42,940
So this is the code I came up
with, which isn't nice at all.

730
00:33:42,940 --> 00:33:44,580
So I definitely need
recursion there,

731
00:33:44,580 --> 00:33:46,470
because I have to nest a
callback inside a callback

732
00:33:46,470 --> 00:33:47,511
inside a callback, right?

733
00:33:47,511 --> 00:33:48,892
So I need recursion.

734
00:33:48,892 --> 00:33:50,850
This is the shortest code
I could come up with.

735
00:33:50,850 --> 00:33:52,140
It copies arrays.

736
00:33:52,140 --> 00:33:53,016
Don't do that.

737
00:33:53,016 --> 00:33:54,390
It's wasteful in
terms of memory,

738
00:33:54,390 --> 00:33:56,490
wasteful in terms of time.

739
00:33:56,490 --> 00:33:57,534
It's quadratic.

740
00:33:57,534 --> 00:33:58,950
But basically, you
have to come up

741
00:33:58,950 --> 00:34:00,870
with something like
this-- like nest callbacks

742
00:34:00,870 --> 00:34:02,120
into callbacks into callbacks.

743
00:34:02,120 --> 00:34:06,570
And so you can't just say, OK,
repeat this five times, right?

744
00:34:06,570 --> 00:34:10,440
So what I really
want to be able to do

745
00:34:10,440 --> 00:34:16,110
is something like this, where I
just say, OK, send one request,

746
00:34:16,110 --> 00:34:19,469
wait for results, send
the other request.

747
00:34:19,469 --> 00:34:21,150
And then if I want
to repeat something,

748
00:34:21,150 --> 00:34:22,441
just repeat it with a for loop.

749
00:34:25,010 --> 00:34:29,699
So this code here is actually
using the same callbacks.

750
00:34:29,699 --> 00:34:33,030
Only the coroutine abstractions
are distributing this away

751
00:34:33,030 --> 00:34:34,650
from me.

752
00:34:34,650 --> 00:34:39,840
So actually, you can take any
callback-based API you have

753
00:34:39,840 --> 00:34:41,900
now, and turn it into this--

754
00:34:41,900 --> 00:34:44,489
like make it straightforward--

755
00:34:44,489 --> 00:34:46,170
with just a few lines of code.

756
00:34:46,170 --> 00:34:47,159
I'll show you.

757
00:34:47,159 --> 00:34:49,409
So this is calling
the same services,

758
00:34:49,409 --> 00:34:53,320
because I have this
function right here.

759
00:34:53,320 --> 00:34:56,219
So what I'm doing, I'm
just turning the request

760
00:34:56,219 --> 00:35:01,450
into a suspension function
through this simple construct.

761
00:35:01,450 --> 00:35:04,990
That's an extension function
of my callback service.

762
00:35:04,990 --> 00:35:07,650
The first thing I say there
is suspend my coroutines.

763
00:35:07,650 --> 00:35:09,390
So I'm assuming
I'm in a coroutine,

764
00:35:09,390 --> 00:35:12,570
I suspended it right away,
I get my continuation,

765
00:35:12,570 --> 00:35:14,201
and I do my request.

766
00:35:14,201 --> 00:35:14,700
That's it.

767
00:35:14,700 --> 00:35:15,360
I'm suspended.

768
00:35:15,360 --> 00:35:17,170
I'm waiting for a request.

769
00:35:17,170 --> 00:35:18,960
So there it is.

770
00:35:18,960 --> 00:35:23,790
And when the request is done,
I just say resume to coroutine.

771
00:35:23,790 --> 00:35:24,810
That's it.

772
00:35:24,810 --> 00:35:30,360
So this simple lines of code
turns your callback-based API

773
00:35:30,360 --> 00:35:33,980
into a coroutine API
and so makes this--

774
00:35:33,980 --> 00:35:37,920
oh, sorry-- makes
this code into this,

775
00:35:37,920 --> 00:35:40,500
which is a lot more
readable to my sense.

776
00:35:40,500 --> 00:35:42,668
How do you like it?

777
00:35:42,668 --> 00:35:44,480
OK, I see some nods
in the audience.

778
00:35:44,480 --> 00:35:45,630
Thank you.

779
00:35:45,630 --> 00:35:48,370
Yeah, well, actually,
if you wanted

780
00:35:48,370 --> 00:35:52,290
to be a lot more prudent here--

781
00:35:52,290 --> 00:35:54,000
and I'm sure you want to--

782
00:35:54,000 --> 00:35:55,680
you need a catch exceptions.

783
00:35:55,680 --> 00:36:02,670
So catching-- handling your
exceptions is very important.

784
00:36:02,670 --> 00:36:05,280
And that's as easy as this.

785
00:36:05,280 --> 00:36:07,050
Just catch your exception.

786
00:36:07,050 --> 00:36:09,900
Whatever happens on
the-- oh, so sorry.

787
00:36:09,900 --> 00:36:11,110
Not here, of course.

788
00:36:11,110 --> 00:36:16,980
Whatever happens
with your request,

789
00:36:16,980 --> 00:36:21,210
just catch it and
resumeWithException.

790
00:36:21,210 --> 00:36:24,660
So this will propagate
exceptions through coroutines

791
00:36:24,660 --> 00:36:25,350
very nicely.

792
00:36:25,350 --> 00:36:28,980
And you'll be able to write
try catch around here--

793
00:36:28,980 --> 00:36:31,840
like surround this
with try catch--

794
00:36:31,840 --> 00:36:35,280
I'm sorry, whatever-- and
catch exceptions there,

795
00:36:35,280 --> 00:36:36,810
as if it was sequential code.

796
00:36:36,810 --> 00:36:38,760
But underneath, it's
all asynchronous.

797
00:36:38,760 --> 00:36:43,890
You can do HTTP requests like
this, asyncio, file systems.

798
00:36:43,890 --> 00:36:47,160
You can do background
threads-- everything you need.

799
00:36:47,160 --> 00:36:50,520
See how isn't it nice?

800
00:36:50,520 --> 00:36:54,390
And I guess, the last example
I'll be showing you today

801
00:36:54,390 --> 00:36:55,240
is this one.

802
00:36:55,240 --> 00:36:58,690
It's just another showoff for
how coroutines can help you.

803
00:37:02,160 --> 00:37:03,460
Take a look.

804
00:37:03,460 --> 00:37:07,260
So what I want to
do is to create

805
00:37:07,260 --> 00:37:09,360
an infinite stream of numbers.

806
00:37:09,360 --> 00:37:11,250
Who likes infinite
streams of numbers?

807
00:37:11,250 --> 00:37:14,730
I eat them for breakfast.

808
00:37:14,730 --> 00:37:18,270
So I want just a Fibonacci
sequence to be generated here.

809
00:37:18,270 --> 00:37:20,370
And then, I can take 20 of them.

810
00:37:20,370 --> 00:37:22,290
Here, just a sequence of 20.

811
00:37:22,290 --> 00:37:24,360
I can take 200, 2,000.

812
00:37:24,360 --> 00:37:27,780
I can filter, map,
slice, whatever.

813
00:37:27,780 --> 00:37:31,350
So this buildSequence
function is a library function

814
00:37:31,350 --> 00:37:33,270
in the Kotlin standard library.

815
00:37:33,270 --> 00:37:36,294
And it's actually based on the
same mechanism as coroutines.

816
00:37:36,294 --> 00:37:37,960
It doesn't do any
background processing.

817
00:37:37,960 --> 00:37:40,410
It's all in the same thread.

818
00:37:40,410 --> 00:37:43,465
What it does, it takes all the
yield statements from here,

819
00:37:43,465 --> 00:37:44,840
and just puts them
in a sequence.

820
00:37:44,840 --> 00:37:50,260
So if I want to yield something
here, I'll just do it.

821
00:37:50,260 --> 00:37:53,260
I insert 2 into my sequence.

822
00:37:53,260 --> 00:37:54,690
If I want to--

823
00:37:54,690 --> 00:37:59,570
say, if tmp is greater
than 10, continue--

824
00:37:59,570 --> 00:38:04,590
I can skip pieces of my logic.

825
00:38:04,590 --> 00:38:07,360
So that's as straightforward
as any coroutine.

826
00:38:07,360 --> 00:38:12,180
It gives you a lazy sequence.

827
00:38:12,180 --> 00:38:15,450
So takeaways--
classes are cheap.

828
00:38:15,450 --> 00:38:18,030
Functions are
top-level or local.

829
00:38:18,030 --> 00:38:22,160
No overloading to emulate
your default values.

830
00:38:22,160 --> 00:38:26,340
Use properties, use delegated
properties, use coroutines.

831
00:38:26,340 --> 00:38:28,710
Have a nice Kotlin.

832
00:38:28,710 --> 00:38:33,520
And I want to advertise
some more activities today.

833
00:38:33,520 --> 00:38:36,870
So if you still have questions
that I couldn't take,

834
00:38:36,870 --> 00:38:41,940
you can come over to an office
hour we're having at 12:30.

835
00:38:41,940 --> 00:38:43,740
You can come over
to the sandbox area

836
00:38:43,740 --> 00:38:47,970
C, where we're at the
Kotlin booth, some

837
00:38:47,970 --> 00:38:49,140
of the day at least.

838
00:38:49,140 --> 00:38:51,120
And right after my
talk, there will

839
00:38:51,120 --> 00:38:53,580
be a talk by Jake Wharton
about Android KDX, which

840
00:38:53,580 --> 00:38:54,620
is very exciting.

841
00:38:54,620 --> 00:38:57,520
I believe it's on stage two,
so you're welcome there.

842
00:38:57,520 --> 00:38:59,532
Thank you very much
for your attention.

843
00:38:59,532 --> 00:39:00,945
[APPLAUSE]

844
00:39:01,887 --> 00:39:05,080
[MUSIC PLAYING]

